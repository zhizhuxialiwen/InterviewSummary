# 初窥c++11：lambda函数及其用法

## 1、为什么需要lambda函数？

匿名函数是许多编程语言都支持的概念，有函数体，没有函数名。1958年，lisp首先采用匿名函数，匿名函数最常用的是作为回调函数的值。正因为有这样的需求，c++引入了lambda 函数，你可以在你的源码中内联一个lambda函数，这就使得创建快速的，一次性的函数变得简单了。例如，你可以把lambda函数可在参数中传递给std::sort函数

```c++
#include <algorithm>
#include <cmath>
void abssort(float* x, unsigned N) {
    std::sort(x, x + N,
        // Lambda expression begins
        [](float a, float b) {
            return std::abs(a) < std::abs(b);
        });
}
```

你可能会问，使用函数对象不是也可以吗？是的，函数对象当然没问题，自己写的回调函数，你可以传个函数指针也没有问题。他们有优点也有缺点。**函数对象能维护状态，但语法开销大，而函数指针语法开销小，却没法保存范围内的状态。如果你觉得鱼和熊掌不可兼得，那你可错了。lambda函数结合了两者的优点，让你写出优雅简洁的代码。**

## 2、基本lambda语法

1. 基本形式如下：

`[capture](parameters)->return-type {body}`


[外部变量访问方式说明符] (参数表) -> 返回值类型
{
   语句块
}

[]叫做捕获说明符，表示一个lambda表达式的开始。接下来是参数列表，即这个匿名的lambda函数的参数，->return-type表示返回类型，如果没有返回类型，则可以省略这部分。想知道为什么返回类型可以这么表示，这涉及到c++11的另一特性，参见自动类型推导，最后就是函数体部分了。
我们可以这样输出"hello,world"

```c++
auto func = [] () { cout << "hello,world"; };
func(); // now call the function
```

变量捕获与lambda闭包实现

```c++
string name;
cin >> name;
[&](){cout << name;}();
```

lambda函数能够捕获lambda函数外的具有自动存储时期的变量。函数体与这些变量的集合合起来叫闭包。

|铺货类型|说明|
|:--|:--|
|[] |不截取任何变量|
|[&} |截取外部作用域中所有变量，并作为引用在函数体中使用|
|[=] |截取外部作用域中所有变量，并拷贝一份在函数体中使用|
|[=, &foo] |截取外部作用域中所有变量，并拷贝一份在函数体中使用，但是对foo变量使用引用|
|[bar] |截取bar变量并且拷贝一份在函数体重使用，同时不截取其他变量|
|[x, &y] |x按值传递，y按引用传递|
|[this] |截取当前类中的this指针。如果已经使用了&或者=就默认添加此选项。|

看到这，不禁要问，这魔法般的变量捕获是怎么实现的呢？原来，lambda是通过创建个小类来实现的。这个类重载了操作符()，一个lambda函数是该类的一个实例。当该类被构造时，周围的变量就传递给构造函数并以成员变量保存起来。看起来跟函数对象很相似。

最后，lambda函数的类型是什么呢，答案是std:function。


* 例子

Lambda 表达式实际上是一个函数，只是它没有名字。下面的程序段使用了上面的 Lambda 表达式：
例1
```c++
int a[4] = {11, 2, 33, 4};
sort(a, a+4, [=](int x, int y) -> bool { return x%10 < y%10; } );
for_each(a, a+4, [=](int x) { cout << x << " ";} );
```

这段程的输出结果是：
`11 2 33 4`

程序第 2 行使得数组 a 按个位数从小到大排序。具体的原理是：sort 在执行过程中，需要判断两个元素 x、y 的大小时，会以 x、y 作为参数，调用 Lambda 表达式所代表的函数，并根据返回值来判断 x、y 的大小。这样，就不用专门编写一个函数对象类了。

第 3 行，for_each 的第 3 个参数是一个 Lambda 表达式。for_each 执行过程中会依次以每个元素作为参数调用它，因此每个元素都被输出。

下面是用到了外部变量的Lambda表达式的程序：

```c++
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    int a[4] = { 1, 2, 3, 4 };
    int total = 0;
    for_each(a, a + 4, [&](int & x) { total += x; x *= 2; });
    cout << total << endl;  //输出 10
    for_each(a, a + 4, [=](int x) { cout << x << " "; });
    return 0;
}
```

程序的输出结果如下：
10
2 4 6 8

第 8 行，[&]表示该 Lambda 表达式中用到的外部变量 total 是传引用的，其值可以在表达式执行过程中被改变（如果使用[=]，编译无法通过）。该 Lambda 表达式每次被 for_each 执行时，都将 a 中的一个元素累加到 total 上，然后将该元素加倍。

实际上，“外部变量访问方式说明符”还可以有更加复杂和灵活的用法。例如：
[=, &x, &y]表示外部变量 x、y 的值可以被修改，其余外部变量不能被修改；
[&, x, y]表示除 x、y 以外的外部变量，值都可以被修改。

例如下面的程序：

```c++
#include <iostream>
using namespace std;
int main()
{   
    int x = 100,y=200,z=300;
    auto ff  = [=,&y,&z](int n) {
        cout <<x << endl;
        y++; z++;
        return n*n;
    };
    cout << ff(15) << endl;
    cout << y << "," << z << endl;
}
```

程序的输出结果如下：
100
225
201, 301

第 6 行定义了一个变量 ff，ff 的类型是 auto，表示由编译器自动判断其类型（这也是 C++11 的新特性）。本行将一个 Lambda 表达式赋值给 ff，以后就可以通过 ff 来调用该 Lambda 表达式了。

第 11 行通过 ff，以 15 作为参数 n 调用上面的 Lambda 表达式。该 Lambda 表达式指明，对于外部变量 y、z，可以修改其值；对于其他外部变量，例如 x，不能修改其值。因此在该表达式执行时，可以修改外部变量 y、z 的值，但如果出现试图修改 x 值的语句，就会编译出错。