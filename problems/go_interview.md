# golang 语言面试题

## 1、golang面试基础题

https://www.jishuchi.com/read/go-interview/3435

### 1.1、在go语言中，new和make的区别？

- new

1. new 的作用是初始化一个指向类型的指针(*T)
2. new函数是内建函数，函数定义：func new(Type) *Type
3. 使用new函数来分配空间。传递给new 函数的是一个类型，不是一个值。返回值是指向这个新分配的0值的指针。

- make

1. make 的作用是为 slice，map 或 chan 初始化并返回引用(T)。
2. make函数是内建函数，函数定义：func make(Type, size IntegerType) Type

    > 1）第一个参数是一个类型，第二个参数是长度
    > 2）返回值是一个类型

make(T, args)函数的目的与new(T)不同。它仅仅用于创建 Slice, Map 和 Channel，并且返回类型是 T（不是T*）的一个初始化的（不是零值）的实例。

### 1.2、 在go语言中，Printf()、Sprintf()、Fprintf()函数的区别用法是什么？

都是把格式好的字符串输出，只是输出的目标不一样：

1. Printf()，是把格式字符串输出到标准输出（一般是屏幕，可以重定向）。Printf() 是和标准输出文件(stdout)关联的,Fprintf 则没有这个限制.
2. Sprintf()，是把格式字符串输出到指定字符串中，所以参数比printf多一个char*。那就是目标字符串地址。
3. Fprintf()， 是把格式字符串输出到指定文件设备中，所以参数笔printf多一个文件指针FILE*。主要用于文件操作。Fprintf()是格式化输出到一个stream，通常是到文件。

### 1.3、说说go语言中，数组与切片的区别？

1. 数组 

1）数组是具有固定长度且拥有零个或者多个相同数据类型元素的序列。 数组的长度是数组类型的一部分，所以[3]int 和 [4]int 是两种不同的数组类型。
2）数组需要指定大小，不指定也会根据初始化的自动推算出大小，不可改变 ;
3）数组是值传递;
4）数组是内置(build-in)类型,是一组同类型数据的集合，它是值类型，通过从0开始的下标索引访问元素值。在初始化后长度是固定的，无法修改其长度。当作为方法的参数传入时将复制一份数组而不是引用同一指针。数组的长度也是其类型的一部分，通过内置函数len(array)获取其长度。
5）数组定义：

```c++
var array [10]int
var array = [5]int{1,2,3,4,5}
```

2. 切片 

1）切片表示一个拥有相同类型元素的可变长度的序列。 切片是一种轻量级的数据结构，它有三个属性：指针、长度和容量。
2）切片不需要指定大小;
3）切片是地址传递;
4）切片可以通过数组来初始化，也可以通过内置函数make()初始化 .初始化时len=cap,在追加元素时如果容量cap不足时将按len的2倍扩容；
5）切片定义：
var slice []type = make([]type, len)

### 1.4、解释以下命令的作用？

1. go env: #用于查看go的环境变量
2. go run: #用于编译并运行go源码文件
3. go build: #用于编译源码文件、代码包、依赖包
4. go get: #用于动态获取远程代码包
5. go install: #用于编译go文件，并将编译结构安装到bin、pkg目录
6. go clean: #用于清理工作目录，删除编译和安装遗留的目标文件
7. go version: #用于查看go的版本信息

### 1.5、说说go语言中的协程？

1）协程和线程都可以实现程序的并发执行；
2）通过channel来进行协程间的通信；
3）只需要在函数调用前添加go关键字即可实现go的协程，创建并发任务；
4）关键字go并非执行并发任务，而是创建一个并发任务单元；

### 1.6、说说go语言中的协程与线程区别？

1. 协程

协程，英文名Coroutine。但在 Go 语言中，协程的英文名是：gorutine。它常常被用于进行多任务，即并发作业。没错，就是多线程作业的那个作业。

虽然在 Go 中，我们不用直接编写线程之类的代码来进行并发，但是 Go 的协程却依赖于线程来进行。

2. 协程与线程的区别

- 协程的特点

1）多个协程可由一个或多个线程管理，协程的调度发生在其所在的线程中。
2）可以被调度，调度策略由应用层代码定义，即可被高度自定义实现。
3）执行效率高。
4）占用内存少。

上面第 1 和 第 2 点
我们来看一个例子：

```go
func TestGorutine(t *testing.T) {
	runtime.GOMAXPROCS(1)  // 指定最大 P 为 1，从而管理协程最多的线程为 1 个
	wg := sync.WaitGroup{} // 控制等待所有协程都执行完再退出程序
	wg.Add(2)
	// 运行一个协程
	go func() {
		fmt.Println(1)
		fmt.Println(2)
		fmt.Println(3)
		wg.Done()
	}()

	// 运行第二个协程
	go func() {
		fmt.Println(65)
		fmt.Println(66)
		// 设置个睡眠，让该协程执行超时而被挂起，引起超时调度
		time.Sleep(time.Second)
		fmt.Println(67)
		wg.Done()
	}()
	wg.Wait()
}
```

上面的代码片段跑了两个协程，运行后，观察输出的顺序是交错的。可能是：

```
65
66
1
2
3
67
```

意味着在执行协程A的过程中，可以随时中断，去执协程行B，协程B也可能在执行过程中中断再去执行协程A。

看起来协程A 和 协程B 的运行像是线程的切换，但是请注意，这里的 A 和 B 都运行在同一个线程里面。它们的调度不是线程的切换，而是纯应用态的协程调度。

3. 关于上述代码中，为什么要指定下面两行代码？

```go
runtime.GOMAXPROCS(1)
time.Sleep(time.Second)
```

这需要您去看下 Go 的协程调度入门基础，请看我之前的另外一篇调度分析文章：

- Go 的协程调度机制

如果不设置 runtime.GOMAXPROCS(1)，那么程序将会根据操作系统的 CPU 核数而启动对应数量的 P，导致多个 M，即线程的启动。那么我们程序中的协程，就会被分配到不同的线程里面去了。为了演示，故设置数量 1，使得它们都被分配到了同一个线程里面，存于线程的协程队列里面，等待被执行或调度。

协程特点中的第 3 和 第 4 点。
执行效率高。
占用内存少。
因为协程的调度切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。调度发生在应用态而非内核态。

内存的花销，使用其所在的线程的内存，意味着线程的内存可以供多个协程使用。

其次协程的调度不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，所以执行效率比多线程高很多。

4. 协程和线程的整体对比

|序号|比较的点|	线程|	协程|
|:---|:-------|:----|:-----|
|1   |数据存储|	内核态的内存空间|一般是线程提供的用户态内存空间|
|2   |切换操作|操作最终在内核层完成，应用层需要调用内核层提供的, syscall:底层函数	|应用层使用代码进行简单的现场保存和恢复即可|
|3   |任务调度|由内核实现，抢占方式，依赖各种锁|由用户态的实现的具体调度器进行。例如 go 协程的调度器|
|4   |语音支持程度|绝大部分编程语言|部分语言：Lua，Go，Python ...|
|5   |实现规范|按照现代操作系统规范实现|无统一规范。在应用层由开发者实现，高度自定义，比如只支持单线程的线程。不同的调度策略，等等|

### 1.7、说说go语言中的for循环？

for循环支持continue和break来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环,for循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量

### 1.8、说说go语言中的switch语句？

单个case中，可以出现多个结果选项

只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case

### 1.9、go语言中没有隐藏的this指针，这句话是什么意思？

方法施加的对象显式传递，没有被隐藏起来
golang的面向对象表达更直观，对于面向过程只是换了一种语法形式来表达
方法施加的对象不需要非得是指针，也不用非得叫this

### 1.10、 go语言中的引用类型包含哪些？

数组切片、字典(map)、通道（channel）、接口（interface）

### 1.11、go语言中指针运算有哪些？

可以通过“&”取指针的地址
可以通过“*”取指针指向的数据

### 1.12、说说go语言的main函数

1. main函数不能带参数
2. main函数不能定义返回值
3. main函数所在的包必须为main包
4. main函数中可以使用flag包来获取和解析命令行参数

### 1.13、说说go语言的同步锁？

1. 当一个goroutine获得了Mutex后，其他goroutine就只能乖乖的等待，除非该goroutine释放这个Mutex;
2. RWMutex在读锁占用的情况下，会阻止写，但不阻止读
3. RWMutex在写锁占用情况下，会阻止任何其他goroutine（无论读和写）进来，整个锁相当于由该goroutine独占

### 1.14、说说go语言的channel特性？

1. 给一个 nil channel 发送数据，造成永远阻塞
2. 从一个 nil channel 接收数据，造成永远阻塞
3. 给一个已经关闭的 channel 发送数据，引起 panic
4. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值
5. 无缓冲的channel是同步的，而有缓冲的channel是非同步的

### 1.15、 go语言触发异常的场景有哪些？

1. 空指针解析
2. 下标越界
3. 除数为0
4. 调用panic函数

### 1.16、说说go语言的beego框架？

1. beego是一个golang实现的轻量级HTTP框架
2. beego可以通过注释路由、正则路由等多种方式完成url路由注入
3. 可以使用bee new工具生成空工程，然后使用bee run命令自动热编译

### 1.17、说说go语言的goconvey框架？

1. goconvey是一个支持golang的单元测试框架
2. goconvey能够自动监控文件修改并启动测试，并可以将测试结果实时输出到web界面
3. goconvey提供了丰富的断言简化测试用例的编写

### 1.18、go语言中，GoStub的作用是什么？

GoStub是一款轻量级的单元测试框架，接口友好，可以对全局变量、函数或过程进行打桩。

1. GoStub可以对全局变量打桩
2. GoStub可以对函数打桩
3. GoStub不可以对类的成员方法打桩
4. GoStub可以打动态桩，比如对一个函数打桩后，多次调用该函数会有不同的行为

### 1.19、golang有哪些测试框架？其区别

1. GoConvey
2. GoStub
3. GoMock

### 1.20、说说go语言的select机制？

1. select机制用来处理异步IO问题
2. select机制最大的一条限制就是每个case语句里必须是一个IO操作
3. golang在语言级别支持select关键字

### 1.21、说说进程、线程、协程之间的区别？

- 进程与线程区别

1. 进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元；
2. 同一个进程中可以包括多个线程；
3. 进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束；
4. 线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包括一个线程；
5. 进程的创建调用fork或者vfork，而线程的创建调用pthread_create；
6. 线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源；
7. 进程是资源分配的单位，线程是操作系统调度的单位。

- 进程、线程与协程区别

1. 进程切换需要的资源很最大，效率很低；
线程切换需要的资源一般，效率一般 ；
协程切换任务资源很小，效率高。
2. 多进程、多线程根据cpu核数不一样,可能是并行的,也可能是并发的。
协程的本质就是使用当前进程在不同的函数代码中切换执行，可以理解为并行。 协程是一个用户层面的概念，不同协程的模型实现可能是单线程，也可能是多线程。
3. 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。（全局变量保存在堆中，局部变量及函数保存在栈中）
线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是这样的)。
协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。

4. 一个应用程序一般对应一个进程，一个进程一般有一个主线程，还有若干个辅助线程，线程之间是平行运行的，在线程里面可以开启协程，让程序在特定的时间内运行。

- 线程与协程区别

协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。

### 1.22、map如何顺序读取

map不能顺序读取，是因为他是无序的，想要有序读取，首先的解决的问题就是，把ｋｅｙ变为有序，所以可以把key放入切片，对切片进行排序，遍历切片，通过key取值。